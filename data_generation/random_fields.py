import torch
import math


class GaussianRF(object):
    """
    Class to generate Gaussian random fields with a given power spectrum.
    The power spectrum is given by the formula:     
        E(k) = C * (4 * pi^2 * |k|^2 + tau^2)^(-alpha/2)

    where k: wavenumber
          C: normalization constant
          tau: parameter that controls the scale of the power spectrum
          alpha: parameter that controls the steepness of the power spectrum

    The random field is generated by first sampling random coefficients in the
    frequency domain, where the coefficients are drawn from a normal distribution
    with variance equal to the square root of the power spectrum. The random field
    is then obtained by taking the inverse Fourier transform of the coefficients.
    """

    def __init__(self, dim, size, alpha=2, tau=3, sigma=None, boundary="periodic", device=None):
        self.dim = dim
        self.device = device
        print(f"Class GaussianRF has input dims={self.dim} and using device {self.device}")

        if sigma is None:
            sigma = tau**(0.5*(2*alpha - self.dim))

        k_max = size // 2

        if dim == 1:
            k = torch.cat((torch.arange(0, k_max, device=device), 
                           torch.arange(-k_max, 0, device=device)), 0)

            self.sqrt_eig = size * math.sqrt(2.0) * sigma * ((4 * (math.pi**2) * (k**2) + tau**2)**(-alpha/2.0))
            self.sqrt_eig[0] = 0.0

        elif dim == 2:
            wavenumbers = torch.cat((torch.arange(0, k_max, device=device), 
                                     torch.arange(-k_max, 0, device=device)), 0).repeat(size, 1)

            k_x = wavenumbers.transpose(0, 1)
            k_y = wavenumbers

            self.sqrt_eig = size**2 * math.sqrt(2.0) * sigma * ((4 * (math.pi**2) * (k_x**2 + k_y**2) + tau**2)**(-alpha/2.0))
            self.sqrt_eig[0, 0] = 0.0

        elif dim == 3:
            wavenumbers = torch.cat((torch.arange(0, k_max, device=device), 
                                     torch.arange(-k_max, 0, device=device)), 0).repeat(size, size, 1)

            k_x = wavenumbers.transpose(1, 2)
            k_y = wavenumbers
            k_z = wavenumbers.transpose(0, 2)

            self.sqrt_eig = size**3 * math.sqrt(2.0) * sigma * ((4 * (math.pi**2) * (k_x**2 + k_y**2 + k_z**2) + tau**2)**(-alpha/2.0))
            self.sqrt_eig[0, 0, 0] = 0.0

        self.size = (size,) * dim

    def sample(self, N):
        # Create random coefficients with the appropriate size
        coeff = torch.randn(N, *self.size, 2, device=self.device)

        # Apply the square root of the eigenvalues to the coefficients
        coeff[..., 0] *= self.sqrt_eig
        coeff[..., 1] *= self.sqrt_eig

        # Convert to real space using multi-dimensional inverse FFT
        print("Converting To Real Space")
        u = torch.fft.ifftn(torch.view_as_complex(coeff), s=self.size, dim=list(range(1, self.dim + 1)))
        u = u.real  # Extract the real part after inverse FFT

        return u